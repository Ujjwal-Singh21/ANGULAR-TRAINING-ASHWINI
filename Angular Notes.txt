day-1
-----

important basic commands:
=========================

- angular installation  -> npm install -g @angular/cli@10 

- version check -> ng --version

- create angular app -> ng new testapp

- run it -> ng serve -o,  here (o is for browser instantiation)

- To clear cache -> npm cache clean --force

- un-install it -> npm uninstall -g @angular/cli

- install again -> npm install -g @angular/cli

- to create a component inside a folder, go to that folder then -> ng generate component test1

- https://stackblitz.com/edit/angular


---------------------------------------------------------------------------------------------

day-2
-----

Notes:
======

- FLOW => main.ts -> app.module.ts(container) -> app.component.ts(components) -> Child components.

- By default every component consist of four files
  
  - .ts file      -  for businesslogic
  - .css file     -  for CSS related stuffs
  - .html file    -  for presentation template purpose
  - .spec.ts file -  for testing purpose

- index.html is the ONLY file which basically gets served up in the browser.

- main.ts is the entry point, it has module name inside bootstrapModule(AppModule) -> 

- app.module.ts acts as a 'container/module' containing several components 
  (has declarations array and used to register components)

- then comes 'components' like app.component.ts having business logic and corresponding app.component.html
  having for presentation or UI logic.

- every component.ts file has a selector tag where we give it a unique name using which we can serve it up.

- like for eg app.component.ts has selector name as 'app-root' which is used inside index.html to serve it
  up in the browser.

- So we can simply say that app component is parent component generated by default.

- And whatever component we are going to create by ourselves hereafter is going to be child component
  of app component

- To establish the PARENT-CHILD relationship, we use the child component's selector name as tag inside
  the parent component's .html file, or so called presentation/template file.


for eg:
-------

- We create a Basics folder inside app folder.

- We move inside Basics folder

- we use 'ng generate component test1' command to create our own test1 component

- It automatically generates four files (.ts, .html, .css, .spec.ts) as mentioned above.

- then we go inside test1.component.ts and copy and select its selector name.

- then we go inside app.component.html file and paste it inside '<>' and use it as tag name .

- Hence parent child relationship is created between app and test1 successfully.


-----------------------------------------------------------------------------------------------------------------------------

day-3
-----

Directives in Angular
=====================

- To conditionally render the dom elements based on certain condition we need directives.

- If we want to manupulate the dom layout/structure based on some condition, then definitely we need something
  more than normal HTML.

- Hence we have directives which helps us to put extra behaviours to dom elements.

- There are various types of directives.


1) Structural Directive
========================

- *ngIf -> its similar to an if condition

- *ngFor -> its similar to a for loop

- <ng-template> -> Its like the else part of *ngIf, and it gets executed only when if condition is false.
                -> To associate ngIf and <ng-template> we make use of 'template-reference-variable'.
                -> <ng - template #comments> </ ng - template>


- example code snippet
======================

class Product {
   id,name,description,quantity, comments[];
}


product: Product = new Product(101, 'Headphones', 'Wireless', 5, ['Nice', 'Amazing', 'Average']);


<div *ngIf = "product.comments.length == 0; else comments">
	<p> No Comments </p>
</div>


<ng-template #comments>
		
	<ul>
		<li *ngFor = "let comment of product.comments">
             {{comment}}
        </li>
    </ul>

<ng-template>


- Here since ngFor is used on <li> tag,

- <li> tag will be executed and rendered the number of times the for loop is going to run

- Which means basically for all elements inside comments array, <li> tag will get executed.



Parent to Child communication (property binding):
=================================================


 App <-
 Product(Parent) <- 
 ProductList (Contains products list and passes one by one to child) <- 
 ProductItem (Recieves and display each product from its parent 'ProductList Component')

Parent- In Parent template through property binding data is sent to child component.

Child - Variable in parent component is able to recieve data from parent component only if it is decorated with
        @Input() decorator, so import Input at the top from angular-core.


example:
--------

- In ProductList.component.ts -> We have productList array.

- In ProductList.component.html -> We have selector <ProductItem></ProductItem> as its child.

- Hence We will be sending data from Parent's html file to Child's ts file.

- Hence in Parent's html file We write as: 


<div class="container">
  <div class="row">

    <div class="col-md-2" *ngFor="let productElement of productList">
      <!-- parent to child data transfer - 
          put a logic to send the productElement to productItem component for display purpose -->
      <app-productitem [product]="productElement"></app-productitem>
    </div>
    
  </div>
</div>

- In Child's ts file we recieve it by annoating a variable with @Input()


import { Component, OnInit, Input } from '@angular/core';
import { Product } from 'src/shared/product.model';

@Component({
  selector: 'app-productitem',
  templateUrl: './productitem.component.html',
  styleUrls: ['./productitem.component.css']
})
export class ProductitemComponent implements OnInit {

  @Input() product:Product; //input prop i.e this will always recieve the value from parent component property

  constructor() { }

  ngOnInit(): void {
  }

}


- Then finally in Child's html file we use the recieved data from parent i.e) product

<div class="shadow-lg -3 mb-5 bg-white rounded">

    <div>
      <h4>{{ product.title }}</h4>
    </div>

    <span class="align-middle">
      <img [src]="product.imagepath" alt="{{ product.title }}" class="img-fluid" />
    </span>

    <div *ngIf="product.comments.length == 0; else comments">
      <p>No Comments</p>
    </div>

    <ng-template #comments>
      <strong> Comments </strong>
      <ul class="list-group list-group-flush">
        <li class="list-group-item" *ngFor="let comment of product.comments">
          {{ comment }}
        </li>
      </ul>
    </ng-template>
</div>


-------------------------------------------------------------------------------------------------------------------


day-4
-----

Two way communication:
======================

- ngModel, @Output, EventEmitter are newly introduced.

- Product component will have 2 childs now which are:

  1) ProductList
  2) ProductCreate

- So we place ProductCreate selector as tag in Product's html file and make it a child of Product component.

- We will take data from user for creating a Product object by using a form in ProductCreate html file.

- We then need to pass that data to ProductList sibling component's ts file.

- But we cannot pass the data directly, hence we will pass it through parent Product component.

- So flow of data will be from ProductCreate - to - Product then from Product - to - ProductList.

- So to create a form in ProductCreate ts file we declare four variables in its ts file first for title,
  description, imagepath and quantity.

- We also declare an onClick event handler method in ts file that creates a Product object inside it when the button
  is clicked because by then variables will be populated with data entered by user through form.

- To bind these variables and handler present in .ts file to the form input and button tag in html file we use
 'ngModel' directive and (click) respectively.

 - syntax: [(ngModel)] = 'title'

 - eg: <input type="text" class="form-control" [(ngModel)]="title" />

 - syntax: (click)="onAddNewProduct()"

 - eg: <button class="btn btn-primary mb-3" (click)="onAddNewProduct()"> Add New Product </button>

- To emit the data from CreateProduct to Product we make use of EventEmitter Object and @Output annotator
  and emit the created Product object using emit() function.

 - @Output() addProductEvent = new EventEmitter<Product>();

 - onAddNewProduct() {
    let newProduct = new Product(this.title, this.description, this.imagepath, this.quantity);
    this.addProductEvent.emit(newProduct);
  }


ProductCreate.component.html (form):
------------------------------------

<div class="container">
  <div class="row">

    <div class="mb-3">
      <label for="title" class="form-label">Title</label>
      <input type="text" class="form-control" [(ngModel)]="title" />
    </div>

    <div class="mb-3">
      <label for="description" class="form-label">Description</label>
      <input type="text" class="form-control" [(ngModel)]="description" />
    </div>

    <div class="mb-3">
      <label for="imagepath" class="form-label">ImageUrl</label>
      <input type="text" class="form-control" [(ngModel)]="imagepath" />
    </div>

    <div class="mb-3">
      <label for="quantity" class="form-label">Quantity</label>
      <input type="number" class="form-control" [(ngModel)]="quantity" />
    </div>

    <button class="btn btn-primary mb-3" (click)="onAddNewProduct()"> Add New Product </button>

  </div>
</div>



ProductCreate.component.ts (variables & onClick handler)
---------------------------------------------------------
import { Component, OnInit, Output, EventEmitter } from '@angular/core';
import { Product } from 'src/shared/product.model';

@Component({
  selector: 'app-productcreate',
  templateUrl: './productcreate.component.html',
  styleUrls: ['./productcreate.component.css']
})
export class ProductcreateComponent implements OnInit {

  // watch-here
  title: string;
  description: string;
  imagepath:string;
  quantity:number;

  // watch-here
  @Output() addProductEvent = new EventEmitter<Product>();

  constructor() { }

  ngOnInit(): void {
  }

  // watch-here
  onAddNewProduct() {
    let newProduct = new Product(this.title, this.description, this.imagepath, this.quantity);
    this.addProductEvent.emit(newProduct);
  }

}


- Since now the data is passed from ProductCreate to Product, we recieve it in Product's html file.

- The data was emitted with the variable named addProductEvent, so data is captured in Product's html file using
  same variable.

- Once we recieve the data in Product's html file, we pass it to its .ts file using a handler method where we have
  declared an empty array to store the recieved product object data and an handler to perform this data assignment.

- storeProducts: Product[] = [];

- onAddNewProduct (newProduct: Product) {
    this.storeProducts.push(newProduct)
    console.log(this.storeProducts)
  }


Product.component.html:
-----------------------

- <app-productcreate (addProductEvent)="onAddNewProduct($event)"></app-productcreate>


Product.component.ts:
---------------------

import { Component, OnInit } from '@angular/core'
import { Product } from 'src/shared/product.model'

@Component({
  selector: 'app-product',
  templateUrl: './product.component.html',
  styleUrls: ['./product.component.css']
})
export class ProductComponent implements OnInit {

  storeProducts: Product[] = [];

  constructor () {}

  ngOnInit (): void {}

  onAddNewProduct (newProduct: Product) {
    this.storeProducts.push(newProduct)
    console.log(this.storeProducts)
  }
  
}



- Now the data is successfully recieved from ProductCreate to Product.ts file and stored in the variable called
  storeProducts which is basically an array holding all Product objects that are created.

- Now we need to pass this data from this variable to ProductList's ts file.

- So we use day-2 logic of passing from Product html file by making changes on ProductList selector tag variable
  and recieving it in ProductList ts file using @Input.


Product.component.html:
-----------------------

- <app-productlist [productList]="storeProducts"></app-productlist> // changes done here

- <app-productcreate (addProductEvent)="onAddNewProduct($event)"></app-productcreate> // already existing line


ProductList.component.ts:
-------------------------

- We comment out the existing hard-coded product objects and initialize it using @Input()

- @Input() productList: Product[];

- Now the data is finally present in our required component ts file inside productList[] array;

- Hence we simply make use of it in ProductList html file and render the desired output.



Approaches of creating forms in Angular:
========================================

- In Angular there are 2 approaches to design interactive forms.

  1) Template Driven Approach
  2) Reactive Approach

1) Template Driven approach:
----------------------------

- Template driven apparoach can be used to create any type of forms

- The UI logic/design i.e) binding the elements to data properties, validation, styling etc is controlled through template.

- Import and register FormsModules in app.module.ts from @angular/forms.

- This FormsModules will provide some important directives to be used in Template-driven-form.

- ngModel -> It is used for 2 way binding.
          -> Bind it to some property of component, it also allow us to check the validity of user input and handle the
             errors.

- ngForm -> Create the Top Level instance of the FormGroup and it is bound to <form> element.
         -> It aggregates or collects the input elements into the single formgroup instance.


- ngSubmit -> used on <form> tag to handle form submit event.


CSS class used in template driven form for checking the validation:
===================================================================

- touched : true if the element was visited by user

- untouched : true if the element was not visited by user

- dirty : true if the element's content was changed

- pristine : true if the element's content was not changed

- valid : true if contents are valid

- Invalid : true if contents are invalid.


Changes we are going to do in ProductCreate.component.html file's form to make it template driven form:
=======================================================================================================

- Wrap all div and button tag inside a <form> tag.

- Create the Top Level instance of the FormGroup using ngForm directive and assign it to a reference variable.
  
  eg: #productForm="ngForm"

- It aggregates/collects the input elements into the single formgroup instance.

- Remove all properties/variables that were declared inside ProductCreare .ts file, because in realtime if we have 100
  properties, we cannot keep declaring them using 100 variables manually, hence it is internally taken care by FormGroup
  instance created above at <form> tag.

- Move the submit handler to <form> tag from <button> tag and make use of ngSubmit directive.

- Pass the FormGroup instance to handler method while invoking it using FormGroup reference variable.

   eg: (ngSubmit)="onAddNewProduct(productForm)

- we make some changes in ts file's submit handler method.

- We recieve FormGroup instance named productForm of type NgForm.

- We change this.title --  productForm.value.title
            this.description -- productForm.value.description etc.

- eg: onAddNewProduct(productForm:NgForm)
       {
           let newproduct=new Product(productForm.value.title,productForm.value.description,
           productForm.value.imagepath,productForm.value.quantity);
           this.addproductevent.emit(newproduct);
       }

- Earlier on <input/> tag ngModel directive was used to bind with all properties like this : [(ngModel)]="title"

- But since now properties are removed we simply write ngModel there without any brackets.

- Since every input element is unique and is for capturing different values from user to create Product Object, we declare
  'name' attribute on every input tag.

- eg: ngModel name="title"

- Internally everything will be binded and data will be passed from html to ts file by help of FormGroup instance.


ProductCreate.component.html:
-----------------------------

<div class="container">
  <div class="row">

    <form #productForm = 'ngForm' (ngSubmit) = 'onAddNewProduct(productForm)'>
      <div class="mb-3">
        <label for="title" class="form-label">Title</label>
        <input type="text" class="form-control" ngModel name ="title" />
      </div>
  
      <div class="mb-3">
        <label for="description" class="form-label">Description</label>
        <input type="text" class="form-control" ngModel name ="description" />
      </div>
  
      <div class="mb-3">
        <label for="imagepath" class="form-label">ImageUrl</label>
        <input type="text" class="form-control" ngModel name ="imagepath" />
      </div>
  
      <div class="mb-3">
        <label for="quantity" class="form-label">Quantity</label>
        <input type="number" class="form-control" ngModel name ="quantity" />
      </div>
  
      <button class="btn btn-primary mb-3"> Add New Product </button>
    </form>
  </div>
</div>


Adding validations in above form:
---------------------------------

- Again ngModel directive helps us to perform validations in given form.

- We assign ngModel directive to a template referecnece variable.

- Using this variable we can conditionally render the error messages.

- ngModel internall provides some above discussed CSS for performing validations like touched, dirty, Valid etc.

- We make every form input field as required.

- And using template reference variable we write condition like if the input field is touched/visited by user and
  specified validation is not fullfilled then display the error message.

  eg:  #title = 'ngModel' required

- Now above input filed will look like this,

  eg:  <input type="text" class="form-control" ngModel name ="title"
        #title = 'ngModel' required />
        <div *ngIf = 'title.touched && title.invalid'> Title is required </div>

- Finally we make Add button to be disabled untill form is correctly filled and validated by user.

- We make use of FormGroup reference variable to do this.

- We set [disabled] = 'productForm.form.invalid'

- <button class="btn btn-primary mb-3" [disabled] = 'productForm.form.invalid'> Add New Product </button>


Same form after adding validations:
-----------------------------------

<div class="container">
  <div class="row">

    <form #productForm = 'ngForm' (ngSubmit) = 'onAddNewProduct(productForm)'>
      <div class="mb-3">
        <label for="title" class="form-label">Title</label>
        <input type="text" class="form-control" ngModel name ="title"
        #title = 'ngModel' required />
        <div *ngIf = 'title.touched && title.invalid'> Title is required </div>
      </div>
  
      <div class="mb-3">
        <label for="description" class="form-label">Description</label>
        <input type="text" class="form-control" ngModel name ="description" 
        #description='ngModel' required/>
        <div *ngIf = 'description.touched && description.invalid'> Description is required </div>
      </div>
  
      <div class="mb-3">
        <label for="imagepath" class="form-label">ImagePath</label>
        <input type="text" class="form-control" ngModel name ="imagepath"
        #imagepath = 'ngModel' required />
        <div *ngIf = 'imagepath.touched && imagepath.invalid'> ImagePath is required </div>
      </div>
  
      <div class="mb-3">
        <label for="quantity" class="form-label">Quantity</label>
        <input type="number" class="form-control" ngModel name ="quantity"
        #quantity = 'ngModel' required />
        <div *ngIf = 'quantity.touched && quantity.invalid'> Quantity is required </div>
      </div>
  
      <button class="btn btn-primary mb-3" [disabled] = 'productForm.form.invalid'> Add New Product </button>
    </form>
  </div>
</div>



------------------------------------------------------------------------------------------------------------------------------

Day-5:
======

Service Communication:
======================

- The main goal of creating services is code reusability.

- We keep business logic centralized inside service.ts file generated using ng g c product

- This service file is injectable as annotated with @Injectable() annotator and hence can be consumed by diff components.

- We keep productList inside service file and it is consumed inside productList component.


Steps:
------

1) Create servicecommunication file

2) Remove all components related to product from app.module.ts

3) Generate again ProductCreate, Product, ProductList and ProductItem components inside servicecommunication file.

4) Inside Shared folder use command ng g s product to genrate product.service.ts file.

5) Create a productList[] array inside service.

6) Create a getter function getUpdatedProductList() which returns a copy of productList array i.e) [...productList]

7) Also create an addProduct() method that recieves values from ProductCreate form and creates a new product instance
   and pushes it inside productList[] array

  eg:  addProduct(title: string, description: string, imagepath: string, quantity: number ) {
           let newProduct = new Product(title, description, imagepath, quantity);
           this.productList.push(newProduct);
           console.log(this.productList);
      }

8) Now Service is ready.

9) Go inside productlist.component.ts since it is only going to consume list of products from service.

10) constructor() {} is used to inject productService instance
    
    eg: constructor(private productService: ProductService) { }

11) ngOnInit() lifecycle hook is used to initialize the class's member variables.

12) We declare a productList[] array of type Product.

13) Inside ngOnInit() lifecycle hook we call getProducts() method of service class suing its instace injected in constructor.

15) We initialize our declared productList[] with the list of products we have got from service.

   eg:  ngOnInit(): void {
         this.productList = this.productService.getProducts();
       }


Problem occuring now:
---------------------

- In browser we can see the hard-coded list of products from service.

- But when we are adding new product through form, its getting created, pushed and added inside service class's 
  productList[] array.

- We can see that using console.log() inside addProduct() method of service.

- But the issue is newly added product or we can say updated Product List is not getting recieved in productlist component.


Solution:
---------

- Hence we make use of Subject observable.

- We create Subject observable instance from rxjs in service class and use it to publish updatedProductList.

- productlist component then subscribes to this observable and recieves updated product list.

- The changes are successfully seen in browser ui.


Observable:
===========

Observable - Unicast in nature, for every subscription a separate instance of observable is created.
           - Therefor every subscription needs to be handled separately.

   Subject - Type of observable that is multicast in nature.
           - Only one instance is created for all subscriptions.
           - Therefore any change in data will be multicasted to all subscribers.



Steps to follow to implement observable:
========================================

product.service.ts
==================

  // creating the Subject Observable which is multicast and helps in publishing updated Product List
  //------------------------------------------------------------------------------------------------
  private updatedProductList = new Subject<Product[]>();

  // Since subject observable is private hence required getter method and return it asObservable()
  //----------------------------------------------------------------------------------------------
  getUpdatedProductList() {
    return this.updatedProductList.asObservable();
  }

  //add this line inside addProduct() method
  //----------------------------------------
  this.updatedProductList.next([...this.productList]);


addProductMethod() after above update:
--------------------------------------
addProduct(title: string, description: string, imagepath: string, quantity: number ) {
    let newProduct = new Product(title, description, imagepath, quantity);
    this.productList.push(newProduct);

    this.updatedProductList.next([...this.productList]);

    console.log(this.productList);
  }




productlist.component.ts
========================

 // here we have subscribed and recieved the updated productList
    this.productService.getUpdatedProductList().subscribe((updatedProductList: Product[]) => {
      this.productList = updatedProductList;

ngOnInit() hook after above update:
-----------------------------------

  ngOnInit(): void {
    this.productList = this.productService.getProducts();

    // here we have subscribed and recieved the updated productList
    this.productService.getUpdatedProductList().subscribe((updatedProductList: Product[]) => {
      this.productList = updatedProductList;
    })
  }



Api-Communication:
==================

1) Clear app.module.ts and make project fresh.

2) Inside app create a new folder apicommunication.

3) Generate product, productlist, productitem components inside it.

4) copy paste the existing templates for item and list. 

   4.1) Inside productlist.component.ts -> declare and empty productList[] array.

5) Inside apicommunication folder -> npm install angular-in-memory-web-api --save

6) Inside shared folder -> ng g s inmemorydata

7) inmemorydata.service.ts is not a regular service class.
   It is a special service class that is going to expose the data at some endpoint.

8) implements the class to InMemoryDbService interface (from angular-in-memory-web-api).

9) Override the createDb() method to simulate the data server.

10) create a similar hardcoded productList[] array inside this method.

11) return {products: productList} from this method.
    Here products is key and productList is the value that is going to be exposed.
    at -> api/products
 
inmemorydata.service.ts:
------------------------
import { Injectable } from '@angular/core'
import { InMemoryDbService, RequestInfo } from 'angular-in-memory-web-api'
import { Observable } from 'rxjs'
import { Product } from './product.model'

@Injectable({
  providedIn: 'root'
})
export class InmemorydataService implements InMemoryDbService {

  createDb (reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}> {
    
    let productlist: Product[] = [
      new Product(
        'InMem Headphones',
        'Wireless',
        'https://cdn.pixabay.com/photo/2018/09/17/14/27/headphones-3683983__480.jpg',
        5
      ),
      new Product(
        'InMem BT Headphones',
        'Wireless',
        'https://cdn.pixabay.com/photo/2018/09/17/14/27/headphones-3683983__480.jpg',
        5
      ),
      new Product(
        'InMem Boat Headphones',
        'Wireless',
        'https://cdn.pixabay.com/photo/2018/09/17/14/27/headphones-3683983__480.jpg',
        5
      ),
      new Product(
        'InMem JAbra Headphones',
        'Wireless',
        'https://cdn.pixabay.com/photo/2018/09/17/14/27/headphones-3683983__480.jpg',
        5
      )
    ]

    return { products: productlist } // api/products
  }

  constructor () {}
}


12) Now we have to register this special service class in app.module.ts so that the simulation server will be on and data
    will be exposed at url endpoint.

13) So under imports[] we have to register that angular service which is responsible for simulation of data server.

14) HttpClientInMemoryWebApiModule.forRoot(InmemorydataService,
      {dataEncapsulation: false})

  - dataEncapsulation: false -> data will be stored directly inside response object.

  - dataEncapsulation: true -> data will be stored inside response object data property.

  - Inside forRoot() we have registered our created special service class.

15) Also import HttpClientModule, which exposes the class which is responsible to respond to http calls.

    eg: inmemorydata.service.ts, special service class in our case is exposed here by including this.

16) Now we create another angular service inside shared folder which is going to send api calls.

17) Inside shared -> ng g s apiproductcommunication

18) Inside the newly created service class, declare url to make api call as private.

    eg: private productsUrl = 'api/products'

19) Inject HttpClient object inside constructor.
 
    eg: constructor(private http: HttpClient) { }

   - By injecting like this we can say that we somewhat got hold of instance of special service class which is 
     inmemorydata.service.ts

20) Then declare a getProducts() method which is going to make http api call and get list of products in the form of
    Observable Product array.

    getProducts() : Observable<Product[]> {
    return this.http.get<Product[]>(this.productsUrl);
    }

apiproductcommunication.service.ts:
-----------------------------------

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { Product } from './product.model';

@Injectable({
  providedIn: 'root'
})
export class ApiproductcommunicationService {

  private productsUrl = 'api/products'

  constructor(private http: HttpClient) { }

  getProducts() : Observable<Product[]> {
    return this.http.get<Product[]>(this.productsUrl);
  }
}


Inside productlist.component.ts:
--------------------------------

1) Since everything is done now and our service class is doing api call to special service class using url and getting
   list of products in the form of Observable Product array.

2) We inject the dependecy of apiproductcommunicationservice inside constructor.

   eg: constructor(private apiproductcommunicationservice: ApiproductcommunicationService) { }


3) Inside ngOnInit() hook we use dependency instance and make call to getProducts() method of service class and subscribe
   to it.

  eg:  ngOnInit(): void {
            this.apiproductcommunicationservice.getProducts()
            .subscribe((productListFromService: Product[]) => {
            this.productList = productListFromService;
          })
       }

4) Inside subsribe() method callback we recieve list of products using which we initializes and set to our empty declared
   productList[] array.


productlist.component.ts:
=========================
import { Component, OnInit } from '@angular/core';
import { ApiproductcommunicationService } from 'src/shared/apiproductcommunication.service';
import { Product } from 'src/shared/product.model';

@Component({
  selector: 'app-productlist',
  templateUrl: './productlist.component.html',
  styleUrls: ['./productlist.component.css']
})
export class ProductlistComponent implements OnInit {

  productList: Product[];

  constructor(private apiproductcommunicationservice: ApiproductcommunicationService) { }

  ngOnInit(): void {
    this.apiproductcommunicationservice.getProducts()
    .subscribe((productListFromService: Product[]) => {
      this.productList = productListFromService;
    })
  }

}



-----------------------------------------------------------------------------------------------------------------------------

Day-6:
======

http post request:
==================

1) To make http post req and add a new product through form, we make product create component inside apicomm folder.

2) Everytime a new product is going to get added, a new Id is going to generated for it by the genId)() method.

3) Inside special service class(inmemorydata.service.ts) -> we declare genId() method

   eg:  // by default internally it gets above productlist as parameter
        genId(products: Product[]): number {
            return products.length > 0 ? Math.max(...products.map(prod => prod.id)) + 1
                               : 1;
        }

4) Inside normal service class (apiprodcomm.service.ts) -> we declare addProduct() method.

eg: // add/post
     addProduct(title: string, description: string, imagepath: string, quantity: number): Observable<Product> {
       const product = {
          title: title,
          description: description,
          imagepath: imagepath,
          quantity: quantity,
      }
     return this.http.post<Product>(this.productsUrl, product);
    }

- This method gets called by productcreate component by passing product details recieved from form.

- This method recieve all product details and makes a JSON object using it.

- Then it makes post() request to special service class / server.

- This methods simply returns the added product in Observable form.

5) Inside productcreate.component.ts -> We inject service class dependency through constructor.

   eg: constructor(private apiproductcommunicationservice: ApiproductcommunicationService) { }

6) Inside onAddProduct() handler we call addProduct() method from service and subscribe it because that method returns
   same added product in Observable form.


productcreate.component.ts:
===========================

import { Component, OnInit } from '@angular/core';
import { NgForm } from '@angular/forms';
import { ApiproductcommunicationService } from 'src/shared/apiproductcommunication.service';

@Component({
  selector: 'app-productcreate',
  templateUrl: './productcreate.component.html',
  styleUrls: ['./productcreate.component.css']
})
export class ProductcreateComponent implements OnInit {

  constructor(private apiproductcommunicationservice: ApiproductcommunicationService) { }

  ngOnInit(): void {
  }

  onAddNewProduct(productForm: NgForm) {
   
    this.apiproductcommunicationservice.addProduct(productForm.value.title, productForm.value.description,
      productForm.value.imagepath, productForm.value.quantity)
      .subscribe((response) => {
        console.log(response);
      })
  }


}

problem occuring now:
=====================

- Everything is working well but updated product list is not getting read by reader component (productlist).


Solution:
==========

- Declare a boolean Observable inside service class

- publish it immediately to make it true when a new product is added inside productcreate component.

- make reader component subscribe to this boolean Observable as well and make the get api call again whenever this
  boolean observable returns true.


1) Inside service class declare -> productListUpdated = new Subject<boolean>();

   It is not declared as private now as done earlier during service communication, so that any component can easily access it.

2) Inside product create class inside onAddNewProduct() method -> 

       // as soon as new product is added by user, we set Observable flag to true 
        this.apiproductcommunicationservice.productListUpdated.next(true);


eg:  onAddNewProduct(productForm: NgForm) {
   
    this.apiproductcommunicationservice.addProduct(productForm.value.title, productForm.value.description,
      productForm.value.imagepath, productForm.value.quantity)
      .subscribe((response) => {
        console.log(response);

        // as soon as new product is added by user, we set Observable flag to true 
        this.apiproductcommunicationservice.productListUpdated.next(true);
      })
  }


3) Inside productlist component's ngOnInit() hook: 

 eg:  ngOnInit(): void {
    this.apiproductcommunicationservice.getProducts()
    .subscribe((productListFromService: Product[]) => {
      this.productList = productListFromService;
    })

    // ADDED LINE- making get api call again once new product is added
    this.apiproductcommunicationservice.productListUpdated
    .subscribe((updatedProductListFlag: boolean) => {
      if(updatedProductListFlag) {
        this.apiproductcommunicationservice.getProducts()
        .subscribe((productListFromService: Product[]) => {
        this.productList = productListFromService;
    })
        }
    })
  }



